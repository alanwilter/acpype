#!/usr/bin/python

###############################################################################
# charmmlipid2amber.py
# Version 2.0.3
# 2014-06-05
# Benjamin D. Madej
#
# Usage: 
# charmmlipid2amber.py [-c charmmlipid2amber.csv] -i input.pdb -o output.pdb
#
# Description:
# Processes PDB files for use with Lipid14. Default substitution file is in
# $AMBERHOME/AmberTools/src/etc. This program processes only ATOM, HETATM, and
# TER lines of a PDB file. Other lines will be removed from PDB.
###############################################################################
#Mod. by Stephan Schott V. // Added the possibility to recognize between
#different chain IDs.


# Includes
import sys
import csv
import re
import getopt
import os

# Main
def charmmlipid2amber(inputpdb,outputpdb=None,csv_dict=os.path.abspath(os.path.dirname(sys.argv[0]))+"/charmmlipid2amber.csv"):
    #print os.path.abspath(os.path.dirname(sys.argv[0]))+"/charmmlipid2amber.csv"
    # Process options
    input_file_name=inputpdb
    if outputpdb is not None:
        output_file_name=outputpdb
    else:
        output_file_name=inputpdb.replace(".pdb","_amber.pdb")
    convert_file_name=csv_dict
    if convert_file_name == '':
        amberhome = os.getenv('AMBERHOME')
        if amberhome == None:
            print("Error: charmmlipid2amber.py AMBERHOME not set and -c is not set. Set the AMBERHOME environment variable OR manually specify a substitution file with -c.")
            print("Usage: charmmlipid2amber.py [-c charmmlipid2amber.csv] -i input.pdb -o output.pdb")
            sys.exit(2)
        else:
            # Hard coded into here. This has to be changed if the data file is moved.
            convert_file_name = "%s/dat/charmmlipid2amber/charmmlipid2amber.csv" % (amberhome)
    if os.path.isfile(convert_file_name) != True:
        print("Error: No substitution file found. Check that AMBERHOME is set properly OR the file set with -c is correct.")
        sys.exit(1)
    try:
        input_file  = open(input_file_name, 'r') # File to be processed
    except IOError as err:
        print("Error: ", str(err))
        sys.exit(1)
    input_file_list = [] # File to be processed as a list
    for line in input_file:
        input_file_list.append(line)
    input_file.close()

    # Process residues
    residue_list = [] # List of residue numbers
    residue_start = [] # List of lines where residues start. Line numbers start at 1.
    residue_end = [] # List of lines where residues end, including TER card if present. Line numbers start at 1.
    it0 = 1
    previous_residue = "" # Residue number of the previous line (including TER card). Set to "" if it is not an ATOM record or TER card.
    current_residue = "" # Residue number of the current line (including TER card). Set to "" if it is not an ATOM record or TER card.
    previous_chain = ""
    current_chain = ""
    # Split file into residues by checking columns 23-27 (<99999 residues):
    # First line:
    if (input_file_list[0][0:6] == "ATOM  " or
        input_file_list[0][0:6] == "HETATM"):
        residue_list.append(input_file_list[0][22:28])
        residue_start.append(it0)
        previous_residue = input_file_list[0][22:28] 
        previous_chain = input_file_list[0][21:22]
    elif line[0:3] == "TER":
        previous_residue = ""
        previous_chain = ""
    else:
        previous_residue = ""
        previous_chain = ""
    it0+=1
#TER_trigger to separate residues according to TER flags. Only relevant when packing causes a single residue molecule 
#to be packed at the beginning, and is not properly identified by residue number only
    TER_trigger = False 
    # Rest of lines:
    for line in input_file_list[1:]:
        if line[0:6] == "ATOM  " or line[0:6] == "HETATM":
            current_residue = line[22:28]
            current_chain = line[21:22]
        elif line[0:3] == "TER":
            current_residue = previous_residue
            current_chain = previous_chain
        else:
            current_residue = ""
            current_chain = ""
        if previous_residue != current_residue  or previous_chain != current_chain or TER_trigger:
            # Previous line was not an ATOM or TER:
            if previous_residue == "" or previous_chain == "":
                residue_list.append(current_residue)
                residue_start.append(it0)
                previous_residue = current_residue
                previous_chain = current_chain
            # Current line is not an ATOM or TER:
            elif current_residue == "" or current_chain == "":
                residue_end.append(it0-1)
                previous_residue = current_residue
                previous_chain = current_chain
            # Previous and current line are ATOM or TER:
            else:
                residue_list.append(current_residue)
                residue_start.append(it0)
                residue_end.append(it0-1)
                previous_residue = current_residue
                previous_chain = current_chain
            TER_trigger = False
        it0+=1
        if line[0:3] == "TER":
            TER_trigger = True
    # If the last residue is not closed, define the end:
    if current_residue != "":
        residue_end.append(it0-1)

    # Process substition dictionaries
    try:
        csv_file = open(convert_file_name, 'r') # csv file with all substitutions
    except IOError as err:
        print("Error: ", str(err))
        sys.exit(1)
    # Skip header line of csv file. Line 2 contains dictionary keys:
    csv_file.readline()
    csv_file_reader = csv.DictReader(csv_file) # Dictionary csv reader
    replace_dict = {} # Dictionary of atom name and residue name search and replace
    order_dict = {} # Dictionary of atom name and residue name order
    ter_dict = {} # Dictionary of whether residue should have a TER card based on atom name and residue name. All atom name and residue name in a residue with a TER card will return True.
    num_atom_dict = {} # Dictionary of number of atoms in current residue for the search string
    for line in csv_file_reader:
        replace_dict[line["search"]] = line["replace"]
        order_dict[line["search"]] = int(line["order"])
        ter_dict[line["search"]] = (line["TER"] == "True")
        num_atom_dict[line["search"]] = int(line["num_atom"])
    csv_file.close()

    # Do substitions
    # The search and replace is columns 13-21 in the PDB file:
    # 13-16: atom name
    # 17:      alternate location indicator
    # 18-20: residue name
    # 21:      sometimes used for the residue name
    output_file_list = [] # File to be written in list form (after processing)
    residue_substituted = False # For error checking. True if a substitution occurs.
    for it1 in range(0, len(residue_list)):
        # residue_start and residue_end indices start at 1. 
        # input_file_list indices start at 0.
        input_residue = input_file_list[residue_start[it1]-1:
            residue_end[it1]]
        output_residue = []
        # Process residue only if first atom is in the replacement dictionary:
        if input_residue[0][12:21] in replace_dict:
            residue_substituted = True
            # Check if length of input_residue is correct:
            # Count TER cards in residue for residue length arithmetic
            n_TER_cards = 0
            for line in input_residue:
                if line[0:3] == "TER":
                    n_TER_cards += 1
            if len(input_residue)-n_TER_cards != num_atom_dict[input_residue[0][12:21]]:
                print("Error: Number of atoms in residue does not match number of atoms in residue in replacement data file")
                print(input_residue, num_atom_dict[input_residue[0][12:21]])
                sys.exit(1)
            output_residue = len(input_residue)*[0]
            for it2 in range(0, len(input_residue)):
                line = input_residue[it2]
                if line[0:3] != "TER":
                     search = line[12:21]
                     output_residue[order_dict[search]] = re.sub(search, 
                        replace_dict[search], line)
                else:
                     output_residue[it2] = "TER   \n"
            if ter_dict[input_residue[0][12:21]] == True:
                if input_residue[-1][0:3] != "TER":
                    output_residue.append("TER   \n")
        else:
            output_residue = input_residue
        output_file_list.extend(output_residue)
    # Check if any residues were substituted:
    if residue_substituted == False:
        print("No residues substituted by charmmlipid2amber")
        return input_file_name

    # Write output
    try:
        output_file = open(output_file_name, 'w') # File to be written
    except IOError as err:
        print("Error: ", str(err))
        sys.exit(1)
    output_file.write("REMARK   Packmol generated pdb file, Packmol Memgen estimated parameters\n")
    output_file.write("REMARK   charmmlipid2amber.py transformed file\n")
    for line in output_file_list:
        output_file.write(line)
    output_file.write("END   \n")
    output_file.close()
    return output_file_name

if __name__ == '__main__':
    # Process options
    input_file_name=''
    output_file_name=''
    convert_file_name=''
    try:
        myopts, args = getopt.getopt(sys.argv[1:],"i:o:c:")
    except getopt.GetoptError as err:
        print("Error: ", str(err))
        print("Usage: charmmlipid2amber.py [-c charmmlipid2amber.csv] -i input.pdb -o output.pdb")
        sys.exit(2)
    for o, a in myopts:
        if o == "-i":
            input_file_name = a
        elif o == "-o":
            output_file_name = a
        elif o == "-c":
            convert_file_name = a
        else:
            print("Usage: charmmlipid2amber.py [-c charmmlipid2amber.csv] -i input.pdb -o output.pdb")
            sys.exit(0)
    if input_file_name == '' or output_file_name == '':
        print("Usage: charmmlipid2amber.py [-c charmmlipid2amber.csv] -i input.pdb -o output.pdb")
        sys.exit(2)
    charmmlipid2amber(input_file_name,outputpdb=output_file_name,csv_dict=os.path.abspath(os.path.dirname(sys.argv[0]))+"/charmmlipid2amber.csv")
 

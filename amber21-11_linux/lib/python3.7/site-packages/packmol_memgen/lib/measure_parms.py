#!/usr/bin/python

from __future__ import print_function
import os, sys, math, string, copy, random
import numpy as np
from scipy import integrate
from .pdbremix import data

avogadro = 6.02214086*10**23

def estimated_density(MW):
    density = 1.41 + 0.145*math.exp(float(-MW)/13000)  #Protein Sci. 2004 Oct; 13(10):2825-2828
    return density

def distribute_integer(integer, fracs):
    dist = []
    tot = sum(fracs)
    for frac in fracs:
        d = int(round(integer*frac/tot))
        dist.append(d)
        tot -= frac
        integer -= d
    return dist

def rotation_matrix(axis, theta):
    """
    Return the rotation matrix associated with counterclockwise rotation about
    the given axis by theta radians.
    """
    axis = np.asarray(axis)
    axis = axis/math.sqrt(np.dot(axis, axis))
    a = math.cos(theta/2.0)
    b, c, d = -axis*math.sin(theta/2.0)
    aa, bb, cc, dd = a*a, b*b, c*c, d*d
    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
    return np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],
                     [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],
                     [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]])

def vector_angle(vec1,vec2, ref=[1,1,0]):
    cross = np.cross(vec1,vec2)
    dot = np.dot(vec1,vec2)
    dot /= np.linalg.norm(vec1)*np.linalg.norm(vec2)
    ori = np.dot(cross, ref)
    return np.arccos(dot)

def align_vectors(vec1,vec2, R=None):
    if np.allclose(vec1,np.array([0,0,0])):
        return np.array([0,0,0])
    angle = vector_angle(vec1,vec2)
    if R is None:
        R = rotation_matrix(cross,angle)
    return np.matmul(vec1,R)

def rotate_pdb(pdb_ori,tip_num,pivot_num, ref=[0,0,1],randomize=False,randomize_vec=[0,0,1]):
    pdb = copy.deepcopy(pdb_ori)
    tip = []
    pivot = []
    for res in pdb:
        for atom in pdb[res]:
            if isinstance(tip_num, list):
                if atom[1] in tip_num:
                    tip.append(pdb[res][atom])
            else:
                if atom[1] == tip_num:
                    tip = pdb[res][atom]
            if isinstance(pivot_num,list):
                if atom[1] in pivot_num:
                    pivot.append(pdb[res][atom])
            else:
                if atom[1] == pivot_num:
                    pivot = pdb[res][atom]
    if isinstance(tip_num, list):
        tip = np.mean(tip,axis=0)
    if isinstance(pivot_num,list):
        pivot = np.mean(pivot,axis=0)
    angle = vector_angle(tip-pivot,np.array(ref))
    axis = np.cross(tip-pivot,np.array(ref))   # vector perpendicular to v1 v2 plane
    R = rotation_matrix(axis,angle)
    for res in pdb:
        if randomize:
            angle = random.uniform(0,6.28)
            axis = np.array([0,0,1])
            R = np.matmul(R,rotation_matrix(axis,angle))
        for atom in pdb[res]:
            pdb[res][atom] = align_vectors(pdb[res][atom]-pivot,np.array(ref),R)+pivot
    return pdb

def randomize_pdb(pdb_ori,tip_num,pivot_num, ref=[0,0,1]):
    pdb = copy.deepcopy(pdb_ori)
    tip = []
    pivot = []
    for res in pdb:
        for atom in pdb[res]:
            if isinstance(tip_num, list):
                if atom[1] in tip_num:
                    tip.append(pdb[res][atom])
            else:
                if atom[1] == tip_num:
                    tip = pdb[res][atom]
            if isinstance(pivot_num,list):
                if atom[1] in pivot_num:
                    pivot.append(pdb[res][atom])
            else:
                if atom[1] == pivot_num:
                    pivot = pdb[res][atom]
    if isinstance(tip_num, list):
        tip = np.mean(tip,axis=0)
    if isinstance(pivot_num,list):
        pivot = np.mean(pivot,axis=0)
    angle = random.uniform(0,6.28)
    axis = np.array(ref)
    R = rotation_matrix(axis,angle)
    if len(pdb[res]) > 1:
        for res in pdb:
            for atom in pdb[res]:
                pdb[res][atom] = align_vectors(pdb[res][atom]-pivot,np.array(ref),R)+pivot
    return pdb

def translate_pdb(pdb_ori,target=None,ref_atm=None,vec=None):
    pdb = copy.deepcopy(pdb_ori)
    if target is not None and ref_atm is not None:
        for res in pdb:
            for atom in pdb[res]:
                if atom[1] == ref_atm:
                    ref = pdb[res][atom]
        tran_vec = ref-target
    elif vec is not None:
        tran_vec = vec
    else:
        print("A target and reference atom, or a translation vector has to be provided")
        exit()
    for res in pdb:
        for atom in pdb[res]:
            pdb[res][atom] = pdb[res][atom]-tran_vec
    return pdb

def superimpose_pdb(pdb1,pdb2):

    points = []

    count = 0
    while count < 3:
        key   = pdb1.keys()[count]
        key2  = pdb1[key].keys()[count]
        print(key, key2)
        points.append([pdb1[key][key2],pdb2[key][key2]])
        count += 1

    trans_vec = points[0][1]-points[0][0]
#    print(trans_vec)

    for n, point in enumerate(points):
        points[n][1] = points[n][1]-trans_vec

    angle = vector_angle(points[1][1]-points[0][0],points[1][0]-points[0][0])
    axis = np.cross(points[1][1]-points[0][0],points[1][0]-points[0][0])

    R = rotation_matrix(axis,angle)


    if not np.allclose(align_vectors(points[1][1]-points[0][0],points[1][0]-points[0][0],R),points[1][0]-points[0][0],atol=1e-01):
        print("Flipping!")
        R = rotation_matrix(axis,-angle)

    pdb3 = translate_pdb(pdb2,vec=trans_vec)

    pdb_write(pdb3,outfile="trans.pdb")

    for res in pdb3:
        for atom in pdb3[res]:
            pdb3[res][atom] = align_vectors(pdb3[res][atom]-points[0][0],points[1][0]-points[0][0],R)+points[0][0]

    for n, point in enumerate(points):
        points[n][1] = align_vectors(points[n][1]-points[0][0],points[1][0]-points[0][0],R)+points[0][0]

    pdb_write(pdb3,outfile="rot1.pdb")

    axis = points[1][0]-points[0][0]

    axis_n     = axis/np.linalg.norm(axis)
    vec_proj1  = np.dot((points[2][1]-points[0][0]),axis_n)
    vec_proj2  = np.dot((points[2][0]-points[0][0]),axis_n)
    line_point1 = points[0][0] + vec_proj1*axis_n
    line_point2 = points[0][0] + vec_proj2*axis_n

    angle = vector_angle(points[2][1]-line_point1,points[2][0]-line_point1)

    R = rotation_matrix(axis,angle)


    if not np.allclose(align_vectors(points[2][1]-line_point1,points[2][0]-line_point1,R),points[2][0]-line_point1,atol=1e-02):
#        print("Flipping2!")
        R = rotation_matrix(axis,-angle)

    for res in pdb3:
        for atom in pdb3[res]:
            pdb3[res][atom] = align_vectors(pdb3[res][atom]-line_point1,points[1][0]-line_point1,R)+line_point1

    return pdb3

def sphere_dist(rad, dx, dy=0, dz=0):
    return rad*2*np.arcsin(np.sqrt(dx**2+dy**2+dz**2)/(2*rad))

def sphere_rectangle_area(rad, a, b):
    a = sphere_dist(rad, a)
    b = sphere_dist(rad, b)
    return rad**2*(2*np.pi-4*np.arccos(np.tan(a/(2*rad))*np.tan(b/(2*rad))))

def sphere_integral(a,b,c,r):
    f = lambda z, y, x: 1
    return integrate.tplquad(f, a-r, a+r,
                lambda x: -np.sqrt(r**2-(x-a)**2)+b,             lambda x: np.sqrt(r**2-(x-a)**2)+b,
                lambda x, y: -np.sqrt(r**2-(x-a)**2-(y-b)**2)+c, lambda x, y: np.sqrt(r**2-(x-a)**2-(y-b)**2)+c)[0]

def sphere_integral_square(x_min,x_max,y_min,y_max,z_min=None, z_max=None,r1=None,r2=None, a=0,b=0,c=0):
    f = lambda z, y, x: 1
    if r1 is not None and r2 is not None:
        if r1**2-(x_max-a)**2-(y_max-b)**2 < 0:
            print("Radius is too small for given dimensions!")
            raise ValueError
        return integrate.tplquad(f, x_min, x_max,
                lambda x: y_min,             lambda x: y_max,
                lambda x, y: np.sqrt(r1**2-(x-a)**2-(y-b)**2)+c, lambda x, y: np.sqrt(r2**2-(x-a)**2-(y-b)**2)+c)[0]
    elif z_min is not None and r2 is not None:
        if r2**2-(x_max-a)**2-(y_max-b)**2 < 0:
            print("Radius is too small for given dimensions!")
            raise ValueError
        return integrate.tplquad(f, x_min, x_max,
                lambda x: y_min,             lambda x: y_max,
                lambda x, y: z_min, lambda x, y: np.sqrt(r2**2-(x-a)**2-(y-b)**2)+c)[0]
    elif z_max is not None and r1 is not None:
        if r1**2-(x_max-a)**2-(y_max-b)**2 < 0:
            print("Radius is too small for given dimensions!")
            raise ValueError
        return integrate.tplquad(f, x_min, x_max,
                lambda x: y_min,             lambda x: y_max,
                lambda x, y: np.sqrt(r1**2-(x-a)**2-(y-b)**2)+c, lambda x, y: z_max)[0]
    else:
        raise ValueError

def gauss_rectangle_area(x_min,x_max,y_min,y_max,b,d,h,a=0,c=0):
    f = lambda y, x: np.sqrt(1 + (-h*(x-a)*np.exp(-(x-a)**2/(2*b**2)-(y-c)**2/(2*d**2))/b**2)**2 + (-h*(y-c)*np.exp(-(x-a)**2/(2*b**2)-(y-c)**2/(2*d**2))/d**2)**2)
    return integrate.dblquad(f, x_min, x_max,
                lambda x: y_min,lambda x: y_max)[0]

#print(gauss_rectangle_area(-150,150,-25,25,50,5000,40))
#print(300*50)

def gauss_integral_square(x_min,x_max,y_min,y_max,b,d,h,a=0,c=0,z_min=None, z_max=None, g1=None, g2=None):
    f = lambda z, y, x: 1
    f1= lambda y, x: h*np.exp(-(x-a)**2/(2*b**2)-(y-c)**2/(2*d**2))+g1
    f2= lambda y, x: h*np.exp(-(x-a)**2/(2*b**2)-(y-c)**2/(2*d**2))+g2
    if g1 is not None and g2 is not None:
        if g2-g1 < 0:
            raise ValueError
        return integrate.tplquad(f, x_min, x_max,
                lambda x: y_min,             lambda x: y_max,
                f1, f2)[0]
    elif z_min is not None and g2 is not None:
        if g2-z_min < 0:
            raise ValueError
        return integrate.tplquad(f, x_min, x_max,
                lambda x: y_min,             lambda x: y_max,
                lambda x, y: z_min, f2)[0]
    elif z_max is not None and g1 is not None:
        if z_max-g1 < 0:
            raise ValueError
        return integrate.tplquad(f, x_min, x_max,
                lambda x: y_min,             lambda x: y_max,
                f1, lambda x, y: z_max)[0]
    else:
        raise ValueError

def measure_parms(pdb, leaflet_z, grid=None, move=False, move_vec=[0,0,0], xy_cen=False, z_cen = False, outpdb="PROT.pdb", chain=" ",renumber=False):
    file = open(pdb, "r")
    filelines = file.readlines()
    file.close()
    charge = 0
    mass = 0
    hydrogens = 0 
    track = None
    mem_atoms_mass_up = 0
    mem_atoms_mass_down = 0
    solv_atoms_mass_up = 0
    solv_atoms_mass_down = 0
    new_pdb = []
    x_mem = []
    y_mem = []
    if xy_cen:
        x = []
        y = []
        z = []
        for line in filelines:
            if (line[0:4] == "ATOM" or line[0:6] == "HETATM") and  line[17:20].strip() != "DUM":
#            if line[0:4] == "ATOM" and  line[17:20].strip() != "DUM":
                    x_coord = float(line[30:38])+move_vec[0]
                    y_coord = float(line[38:46])+move_vec[1]
                    z_coord = float(line[46:54])+move_vec[2]
                    x.append(float(x_coord))
                    y.append(float(y_coord))
                    z.append(float(z_coord))
        _x_cen = (max(x)+min(x))/2
        _y_cen = (max(y)+min(y))/2
        _z_cen = (max(z)+min(z))/2
    x = []
    y = []
    z = []
    last_chain   = None
    last_resnum  = None
    resnum_index = 1
    chains = 1
    chain_list   = list(string.ascii_uppercase)
    if chain == " ":
        chain_index  = 0
    else:
        try:
            chain_index = chain_list.index(chain)
        except:
            print("Chain ID not found in list")
            chain_index  = 0
    for line in filelines:
        if line[0:3] == "TER":
            new_pdb.append("TER\n")
            continue
        if (line[0:4] == "ATOM" or line[0:6] == "HETATM") and  line[17:20].strip() != "DUM":
#        if line[0:4] == "ATOM" and  line[17:20].strip() != "DUM":
            residue = line[17:21].strip()
            atomnum = int(line[6:11].strip())
            atomname = line[12:16].strip()
            resnum = int(line[22:26].strip())
            if renumber and resnum != last_resnum:
                last_resnum   = resnum
                resnum_new    = resnum_index
                resnum_index += 1
            if renumber:
                resnum = resnum_new
            segid  = line[72:76].strip()
            if residue == "ILE" and atomname == "CD":
                atomname = "CD1"
            if residue == "CYM":
                if atomname == "HN1" or atomname == "HB1":
                    continue
            if atomname == "OT1":
                atomname = "O"
            if atomname == "OT2":
                atomname = "OXT"
            if len(atomname) == 3:
                ali = ">"
            else:
                ali = "^"
            if chain == " ":
                chain = line[21:22]
            if last_chain is not None and last_chain != line[21:22]:
                new_pdb.append("TER\n")
                chains += 1
                chain_index += 1
                chain = chain_list[chain_index]
                chain = chain_list[chain_index]
            last_chain = line[21:22]
            if not move and not xy_cen:
                x_coord = float(line[30:38])
                y_coord = float(line[38:46])
                z_coord = float(line[46:54])
            elif not move:
                x_coord = float(line[30:38])-_x_cen
                y_coord = float(line[38:46])-_y_cen
                z_coord = float(line[46:54])
                if z_cen:
                    z_coord = float(line[46:54])-_z_cen
            elif not xy_cen:
                x_coord = float(line[30:38])+move_vec[0]
                y_coord = float(line[38:46])+move_vec[1]
                z_coord = float(line[46:54])+move_vec[2]
            else:
                x_coord = float(line[30:38])+move_vec[0]-_x_cen
                y_coord = float(line[38:46])+move_vec[1]-_y_cen
                z_coord = float(line[46:54])+move_vec[2]
                if z_cen:
                    z_coord = float(line[46:54])+move_vec[2]-_z_cen
            x.append(float(x_coord))
            y.append(float(y_coord))
            z.append(float(z_coord))
            line = line[0:6]+"{:>5d} {:{align}4} {:<4}{:1}{:>4}    {:>8.3f}{:>8.3f}{:>8.3f}{:>6.2f}{:>6.2f}      {:<4}{:>2}\n".format( atomnum,atomname,residue,chain,resnum,x_coord,y_coord,z_coord,1,0,segid,atomname[0],align=ali)
#            line = "ATOM  {:>5d} {:{align}4} {:<4}{:1}{:>4}    {:>8.3f}{:>8.3f}{:>8.3f}{:>6.2f}{:>6.2f}      {:<4}{:>2}\n".format( atomnum,atomname,residue,chain,resnum,x_coord,y_coord,z_coord,1,0,segid,atomname[0],align=ali)
            new_pdb.append(line)

            if line[17:20].strip() in charged and track != line[22:26].strip():
                charge += charged[line[17:20].strip()]
                track =  line[22:26].strip()
            #Add masses according to z location
            if line[0:4] == "ATOM":
                element = data.guess_element(residue,atomname)
                if element in data.masses:
                    mass += data.masses[element]
                    if element == "H":
                        hydrogens += 1
                    if z[-1] > leaflet_z:
                        solv_atoms_mass_up += data.masses[element]
                    elif z[-1] < -leaflet_z:
                        solv_atoms_mass_down += data.masses[element]
                    else:
                        if z[-1] >= 0:
                            mem_atoms_mass_up +=  data.masses[element]
                        else:
                            mem_atoms_mass_down +=  data.masses[element]
                        x_mem.append(x[-1])
                        y_mem.append(y[-1])
                else:
                    print("Atom "+element+" mass will not be considered!\n")
    if hydrogens == 0:
        print("Protein doesn't look to be protonated! Please consider that this will cause a bad estimation of the volume and of the packing process!\n\n")
    est_density = estimated_density(mass)
    density = est_density*avogadro/10**24
    volume = mass/density
    mem_vol_up = mem_atoms_mass_up/density
    mem_vol_down = mem_atoms_mass_down/density
    solv_vol_up = solv_atoms_mass_up/density
    solv_vol_down = solv_atoms_mass_down/density

    #### MAXIMUM PROTEIN XY RADIUS ###

    mean_x  = sum(x)/len(x)
    mean_y  = sum(y)/len(y)
    max_rad = max([math.sqrt((x[n]-mean_x)**2+(y[n]-mean_y)**2) for n, _ in enumerate(x)])

    #### IF GRID VOL CALCULATION, REPLACE ESTIMATION ####

    if grid != None:
        file = open(grid,"r").readlines()
        solv_up = 0
        solv_down = 0
        mem_up = 0
        mem_down = 0
        for line in file:
            coord = float(line.split()[7])
            if coord+move_vec[2] > leaflet_z:
                solv_up += 1
            elif coord+move_vec[2] > 0:
                mem_up += 1
            elif coord+move_vec[2] >= -leaflet_z:
                mem_down += 1
            elif coord+move_vec[2] < -leaflet_z:
                solv_down += 1
            else:
                print("Coordinate not assigned?") #Shouldn't be called
        mem_vol_up = mem_up/8
        mem_vol_down = mem_down/8
        solv_vol_up = solv_up/8
        solv_vol_down = solv_down/8
        volume = mem_vol_up+mem_vol_down+solv_vol_up+solv_vol_down
    
    x.sort()
    y.sort()
    z.sort()
    x_mem.sort()
    y_mem.sort()
    try:
        area_est = (((x_mem[-1]-x_mem[0])+(y_mem[-1]-y_mem[0]))/4)**2*math.pi # Maybe estimate the protein area in the membrane...(Not used ATM)
    except:
        print("WARNING! The protein doesn't have atoms sitting in the membrane! Make sure that it was correctly aligned and that the placement is as intended!")
    new_file = open(outpdb,"w")
    new_file.writelines(new_pdb)
    new_file.close()
    return [x[0], y[0], z[0], x[-1], y[-1], z[-1]], max_rad, charge, volume, mem_vol_up, mem_vol_down, solv_vol_up, solv_vol_down, density, mass, chains

residues = {"CYS","CYX","CYM","MET","HIS","HSD","HIE","HID","HIP","HSE","SER","GLN","ASP","ASH","GLU","GLH","TYR","THR","ALA","LEU","ILE","PHE","TRP","ARG","ASN","LYS","LYN","VAL","PRO","GLY", }
cgatoms  = {"CA","CB","C","N","O"}
charged  = {"ASP":-1,"GLU":-1,"LYS":1,"ARG":1,"HIP":1,"Cl-":-1,"MG":2,"Na+":1,"CA":2,"OHE":-0.308100,
            "A":-1,"A5":-0.3081,"A3":-0.6919,"DA":-1,"DA5":-0.3079,"DA3":-0.6921,
            "C":-1,"C5":-0.3081,"C3":-0.6919,"DC":-1,"DC5":-0.3079,"DC3":-0.6921,
            "G":-1,"G5":-0.3081,"G3":-0.6919,"DG":-1,"DG5":-0.3079,"DG3":-0.6921,
            "U":-1,"U5":-0.3081,"U3":-0.6919,"DT":-1,"DT5":-0.3079,"DT3":-0.6921,
            "PTR":-2,"SEP":-2,"TPO":-2,"Y1P":-1,"S1P":-1,"T1P":-1,"H1D": 0,"H2D":-1,"H1E": 0,"H2E":-1}
#masses   = {"C": 12, "S": 32, "O": 16, "H": 1, "N": 14}

def pdb_parse(pdbfile, onlybb=True):
    CA_CB = {}
    pdb = open(pdbfile,"r").readlines()
    for line in pdb:
        if (line.startswith("ATOM") or line.startswith("HETATM")):
            residue = line[17:21].strip()
            atomnum = int(line[6:11].strip())
            atomname = line[12:16].strip()
            resnum = int(line[22:26].strip())
            chain = line[21:22]
            id = (residue,resnum,chain)
            if atomname in cgatoms and residue in residues and onlybb:
                if id not in CA_CB:
                    CA_CB[id]= {}
                CA_CB[id][(atomname,atomnum)] = np.array([float(line[30:38].strip()),float(line[38:46].strip()),float(line[46:54].strip())])
            if not onlybb:
                if id not in CA_CB:
                    CA_CB[id]= {}
                CA_CB[id][(atomname,atomnum)] = np.array([float(line[30:38].strip()),float(line[38:46].strip()),float(line[46:54].strip())])
    return CA_CB

def pdb_write(CA_CB, outfile="test.pdb"):
    handle = open(outfile,"w")
    for res in sorted(CA_CB,key=lambda x:(x[2],x[1])):
        for atom in sorted(CA_CB[res], key=lambda x:x[1]):
#                          ATOM   4691  N   ALA D  70       2.792 -17.706  44.261  1.00  0.00           N
#            print (atom[1],atom[0],res[0],res[2],res[1],CA_CB[res][atom][0],CA_CB[res][atom][1],CA_CB[res][atom][2])
            handle.write("ATOM  {:>5d} {:>4} {:>3}{:>2}{:>4d}    {:>8.3f}{:>8.3f}{:>8.3f}   1.00  0.00           {:1}\n".format(atom[1],"{:<3}".format(atom[0]),res[0],res[2],res[1],CA_CB[res][atom][0],CA_CB[res][atom][1],CA_CB[res][atom][2],atom[0][0]))
    handle.close()
            
if __name__ == "__main__":
    pdb = sys.argv[1]
    print(measure_parms(pdb,23,None))
    if "-move" in sys.argv:
        vec = [float(i) for i in sys.argv[sys.argv.index("-move")+1].split(",")]
        print(measure_parms(pdb,23,move=True, move_vec=vec))
    if "-cen" in sys.argv:
        print(measure_parms(pdb,23,xy_cen=True))
